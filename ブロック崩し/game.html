<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>画像版スマホブロック崩し</title>
    <style>
        /* 背景画像を設定したい場合は、ここのbackgroundを変えてください */
        body { margin: 0; overflow: hidden; background: #333 url('bg.jpg') no-repeat center center; background-size: cover; display: flex; justify-content: center; align-items: center; height: 100vh; touch-action: none; }
        /* Canvasの背景を透明にして、bodyの背景画像が見えるようにします */
        canvas { display: block; border: none; max-width: 100%; max-height: 100%; }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = 360;
canvas.height = 480;

// --- 画像の準備エリア ---
const ballImg = new Image();
ballImg.src = 'ball.png'; // ボールの画像ファイル名

const paddleImg = new Image();
paddleImg.src = 'paddle.png'; // パドルの画像ファイル名

const brickImg = new Image();
brickImg.src = 'brick.png'; // ブロックの画像ファイル名

// 画像が全て読み込まれてからゲームを開始するための仕組み
let imagesLoaded = 0;
const totalImages = 3;
function handleImageLoad() {
    imagesLoaded++;
    if (imagesLoaded === totalImages) {
        // 全ての画像準備完了したらゲームスタート
        draw();
    }
}
// 各画像に読み込み完了時の連絡先を設定
ballImg.onload = handleImageLoad;
paddleImg.onload = handleImageLoad;
brickImg.onload = handleImageLoad;
// ----------------------


// ボールの設定
let x = canvas.width / 2;
let y = canvas.height - 100;
let dx = 3;
let dy = -3;
const ballRadius = 10; // 画像サイズに合わせて少し大きめに調整

// パドルの設定
const paddleHeight = 20; // 画像に合わせて少し高さを調整
const paddleWidth = 80;
let paddleX = (canvas.width - paddleWidth) / 2;
const paddleBottomMargin = 10;

// ブロックの設定
const brickRowCount = 5;
const brickColumnCount = 4;
const brickWidth = 70;
const brickHeight = 25; // 画像に合わせて少し高さを調整
const brickPadding = 10;
const brickOffsetTop = 50;
const brickOffsetLeft = 25;

const bricks = [];
for(let c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(let r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
    }
}

// タッチ・マウス操作
function movePaddle(e) {
    let relativeX;
    if(e.touches) {
        e.preventDefault(); // スマホでのスクロールなどを防ぐ
        relativeX = e.touches[0].clientX - canvas.offsetLeft;
    } else {
        relativeX = e.clientX - canvas.offsetLeft;
    }
    // パドルの中心が指の位置に来るように調整
    if(relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
    }
}
document.addEventListener("touchmove", movePaddle, { passive: false });
document.addEventListener("mousemove", movePaddle);

// 当たり判定
function collisionDetection() {
    for(let c=0; c<brickColumnCount; c++) {
        for(let r=0; r<brickRowCount; r++) {
            let b = bricks[c][r];
            if(b.status == 1) {
                // 簡易的な矩形（四角形）同士の当たり判定
                if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
                    dy = -dy;
                    b.status = 0;
                }
            }
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ブロック描画（画像を使用）
    for(let c=0; c<brickColumnCount; c++) {
        for(let r=0; r<brickRowCount; r++) {
            if(bricks[c][r].status == 1) {
                let brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
                let brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                // fillRectの代わりにdrawImageを使用
                // ctx.drawImage(画像, X座標, Y座標, 幅, 高さ)
                ctx.drawImage(brickImg, brickX, brickY, brickWidth, brickHeight);
            }
        }
    }

    // ボール描画（画像を使用）
    // ボールの中心座標(x, y)から、画像の左上座標を計算して描画
    ctx.drawImage(ballImg, x - ballRadius, y - ballRadius, ballRadius * 2, ballRadius * 2);

    // パドル描画（画像を使用）
    ctx.drawImage(paddleImg, paddleX, canvas.height - paddleHeight - paddleBottomMargin, paddleWidth, paddleHeight);

    collisionDetection();

    // 壁との反射
    // 左右の壁
    if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
        dx = -dx;
    }
    // 天井
    if(y + dy < ballRadius) {
        dy = -dy;
    } 
    // 床（パドルとの判定）
    else if(y + dy > canvas.height - ballRadius - paddleBottomMargin) {
        // ボールのX座標がパドルの幅の範囲内にあるか
        if(x > paddleX && x < paddleX + paddleWidth) {
            // パドルの少し上で跳ね返るように位置を調整（めり込み防止）
            y = canvas.height - ballRadius - paddleBottomMargin - 2;
            dy = -dy;
        } else if (y + dy > canvas.height - ballRadius) {
            // 完全に下に落ちたらゲームオーバー
            alert("GAME OVER");
            document.location.reload();
            return; // ここで処理を止める
        }
    }

    x += dx;
    y += dy;
    requestAnimationFrame(draw);
}

// 画像読み込み設定があるので、ここではdraw()を直接呼ばない
</script>
</body>
</html>