<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>dikko-game DX</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; touch-action: none; font-family: 'Arial', sans-serif; }
        canvas { display: block; border: 2px solid #fff; max-width: 100%; max-height: 100%; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = 360;
canvas.height = 480;

// --- 画像・設定 ---
let lives = 3;
let isClear = false;
let isGameOver = false;

const ballImg = new Image(); ballImg.src = 'ball.png';
const paddleImg = new Image(); paddleImg.src = 'paddle.png';
const bgImg = new Image(); bgImg.src = 'bg.jpg';
const clearImg = new Image(); clearImg.src = 'clear.png';

const ballRadius = 15;
const paddleHeight = 20;
const paddleWidth = 90;
let paddleX = (canvas.width - paddleWidth) / 2;

// ボール管理（配列にして複数対応）
let balls = [];
function createBall(x, y, dx, dy) {
    return { x: x, y: y, dx: dx, dy: dy };
}
function resetGame() {
    balls = [createBall(canvas.width / 2, canvas.height - 100, 3, -4)];
}
resetGame();

// アイテム管理
let items = [];
const itemSize = 20;

// ブロック設定
const brickRowCount = 6;
const brickColumnCount = 5;
const brickWidth = 60;
const brickHeight = 20;
const brickPadding = 6;
const brickOffsetTop = 50;
const brickOffsetLeft = 18;
const brickColors = ["#FF5733", "#33FF57", "#3357FF", "#F3FF33", "#FF33F3", "#33FFF3"];

const bricks = [];
for(let c=0; c<brickColumnCount; c++) {
    bricks[c] = [];
    for(let r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1, color: brickColors[r] };
    }
}

// 操作
function movePaddle(e) {
    let relativeX;
    let clientX = e.touches ? e.touches[0].clientX : e.clientX;
    relativeX = clientX - canvas.offsetLeft;
    if(relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
    }
}
document.addEventListener("touchmove", (e) => { e.preventDefault(); movePaddle(e); }, { passive: false });
document.addEventListener("mousemove", movePaddle);

function update() {
    if(isClear || isGameOver) return;

    // ボールの移動と判定
    balls.forEach((ball, index) => {
        ball.x += ball.dx;
        ball.y += ball.dy;

        // 壁反射
        if(ball.x + ball.dx > canvas.width - ballRadius || ball.x + ball.dx < ballRadius) ball.dx = -ball.dx;
        if(ball.y + ball.dy < ballRadius) ball.dy = -ball.dy;
        
        // パドル反射（角度変化ロジック）
        if(ball.y + ball.dy > canvas.height - 30 - ballRadius) {
            if(ball.x > paddleX && ball.x < paddleX + paddleWidth) {
                // 当たった位置で角度を変える (-0.5 〜 0.5)
                let hitPos = (ball.x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                let speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = hitPos * speed * 0.8; // 端っこほど横に飛ぶ
                ball.dy = -Math.sqrt(speed * speed - ball.dx * ball.dx); // 速度を一定に保つ
            } else if (ball.y + ball.dy > canvas.height) {
                balls.splice(index, 1); // ボールを削除
                if(balls.length === 0) {
                    lives--;
                    if(lives <= 0) isGameOver = true;
                    else resetGame();
                }
            }
        }

        // ブロック衝突
        let allCleared = true;
        for(let c=0; c<brickColumnCount; c++) {
            for(let r=0; r<brickRowCount; r++) {
                let b = bricks[c][r];
                if(b.status == 1) {
                    allCleared = false;
                    if(ball.x > b.x && ball.x < b.x+brickWidth && ball.y > b.y && ball.y < b.y+brickHeight) {
                        ball.dy = -ball.dy;
                        b.status = 0;
                        // 20%の確率でアイテムドロップ
                        if(Math.random() < 0.2) {
                            items.push({ x: b.x + brickWidth/2, y: b.y, type: 'triple' });
                        }
                    }
                }
            }
        }
        if(allCleared) isClear = true;
    });

    // アイテムの移動とパドル取得判定
    items.forEach((item, index) => {
        item.y += 2;
        if(item.y > canvas.height) items.splice(index, 1);
        if(item.y > canvas.height - 30 - itemSize && item.x > paddleX && item.x < paddleX + paddleWidth) {
            // アイテムゲット！ボールを3倍に増やす
            items.splice(index, 1);
            let currentCount = balls.length;
            for(let i=0; i < currentCount; i++) {
                let b = balls[i];
                balls.push(createBall(b.x, b.y, b.dx + 2, -b.dy));
                balls.push(createBall(b.x, b.y, b.dx - 2, -b.dy));
            }
        }
    });
}

function draw() {
    update();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景
    ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

    // シンプルブロック描画
    for(let c=0; c<brickColumnCount; c++) {
        for(let r=0; r<brickRowCount; r++) {
            if(bricks[c][r].status == 1) {
                let brickX = (c*(brickWidth+brickPadding))+brickOffsetLeft;
                let brickY = (r*(brickHeight+brickPadding))+brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.fillStyle = bricks[c][r].color;
                ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
                // 枠線
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
            }
        }
    }

    // アイテム描画
    items.forEach(item => {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(item.x, item.y, 12, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.font = "bold 14px Arial";
        ctx.textAlign = "center";
        ctx.fillText("3", item.x, item.y + 5);
    });

    // ボール・パドル描画
    balls.forEach(ball => {
        ctx.drawImage(ballImg, ball.x - ballRadius, ball.y - ballRadius, ballRadius * 2, ballRadius * 2);
    });
    ctx.drawImage(paddleImg, paddleX, canvas.height - 30, paddleWidth, paddleHeight);

    // UI
    ctx.font = "bold 20px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "left";
    ctx.fillText("LIVES: " + lives, 20, 30);
    ctx.fillText("BALLS: " + balls.length, 250, 30);

    if(isClear) {
        ctx.drawImage(clearImg, 30, 80, 300, 300);
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.font = "bold 40px Arial";
        ctx.fillText("ALL CLEAR!!", canvas.width/2, canvas.height/2);
        return;
    }

    if(isGameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "red";
        ctx.textAlign = "center";
        ctx.font = "bold 40px Arial";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        setTimeout(() => { document.location.reload(); }, 2000);
        return;
    }

    requestAnimationFrame(draw);
}

// 全ての画像が読み込まれたらスタート
let loadedCount = 0;
[ballImg, paddleImg, bgImg, clearImg].forEach(img => {
    img.onload = () => {
        loadedCount++;
        if(loadedCount === 4) draw();
    }
});
</script>
</body>
</html>